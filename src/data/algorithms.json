[
  {
    "id": 0,
    "name": "quick sort",
    "description": "Quick Sort Description",
    "complexity": {
      "timeAvg": "average",
      "timeWorst": "worst",
      "timeBest": "best",
      "space": "space"
    },
    "implementation": "insert code here"
  },
  {
    "id": 1,
    "name": "merge sort",
    "description": "Merge Sort Description",
    "complexity": {
      "timeAvg": "average",
      "timeWorst": "worse",
      "timeBest": "best",
      "space": "space"
    },
    "implementation": "insert code here"
  },
  {
    "id": 2,
    "name": "bubble sort",
    "description": "<p>Bubble sort, named after the way that the largest elements bubble up to the top of the list first, is a sorting algorithm that repeatedly steps through the input list, comparing adjacent elements and swapping their values if needed. This process is continued until a pass is made through the list in which no swaps occurred, signalling that everything is sorted.</p><p>Bubble sort's use is primarily as an educational tool. Its main advantages are as follows. It is in-place, meaning that only constant additional memory is needed. It is adaptive, so the time it takes to run this algorithm is greatly reduced on mostly sorted inputs. And it is stable, so that the relative ordering of elements with equal keys is maintained. However, this algorithm performs more poorly than the similar insertion sort, or even selection sort for that matter. </p><p>Sometimes, the terms \"rabbits\" and \"turtles\" are used to refer to the way certain elements behave within the context of bubble sort. Rabbits are the elements that want to move toward the end of the list, and they can do this very quickly because the algorithm goes from left to right. Turtles are the smaller elements that want to move toward the beginning of the list, but they cannot move faster than one step to the left per pass. The slow speed of turtles presents a bottleneck on the speed of bubble sort as a whole, so there are variations like cocktail sort and comb sort which attempt to minimize this imbalance by making turtles faster.</p>",
    "complexity": {
      "timeAvg": "O(n<sup>2</sup>)",
      "timeWorst": "O(n<sup>2</sup>)",
      "timeBest": "O(n)",
      "space": "O(1)"
    },
    "implementation": "insert code here"
  },
  {
    "id": 3,
    "name": "selection sort",
    "description": "<p>Selection sort is a simple in-place sorting algorithm which divides the input array into a sorted subarray and an unsorted subarray. At each iterative step, it sorts the minimum or maximum value in the unsorted array by removing it and placing it in the appropriate position in the sorted array. Then, it repeats this until all elements are sorted.</p><p>This algorithm is very inefficient on large inputs, and it generally performs worse than the similar insertion sort. Its main advantages are that it is an in-place algorithm and therefore only requires constant auxiliary memory, and it is simple to implement and understand. As a result of its small memory requirement, it may also have performance advantages over more complicated algorithms in certain situations where memory is limited.</p>",
    "complexity": {
      "timeAvg": "O(n<sup>2</sup>)",
      "timeWorst": "O(n<sup>2</sup>)",
      "timeBest": "O(n<sup>2</sup>)",
      "space": "O(1)"
    },
    "implementation": "<span>const selectionSort = (arr) => {</span><span>  for (let i = 0; i < arr.length - 1; i++) {</span><span>    let min = arr[i];</span><span>    let minIndex = i;</span><span>    for (let j = i + 1; j < arr.length; j++) {</span><span>      if (arr[j] < min) {</span><span>        min = arr[j];</span><span>        minIndex = j;</span><span>      }</span><span>    }</span><span>    const temp = arr[i];</span><span>    arr[i] = min;</span><span>    arr[minIndex] = temp;</span><span>  }</span><span>  return arr;</span><span>};</span>"
  },
  {
    "id": 4,
    "name": "insertion sort",
    "description": "<p>Insertion sort is a simple sorting algorithm that builds the final sorted array one element at a time by removing it from the input data, finding the location in which it belongs within the sorted segment, and inserting it there. This process repeats until no input elements remain.</p><p>This algorithm is much less efficient on large inputs than more advanced algorithms such as quick sort, heap sort, or merge sort. However, it has many advantages. It can be done in-place, so it only requires a constant amount additional memory. It is stable, meaning that will preserve the relative order of elements with equal keys. It is adaptive in the sense that it performs well on data sets that are already substantially sorted. And it is very efficient for small data sets.</p>",
    "complexity": {
      "timeAvg": "O(n<sup>2</sup>)",
      "timeWorst": "O(n<sup>2</sup>)",
      "timeBest": "O(n)",
      "space": "O(1)"
    },
    "implementation": "<span>const insertionSort = (arr) => {</span><span>  for (let i = 1; i < arr.length; i++) {</span><span>    let temp = arr[i];</span><span>    let j = i - 1;</span><span>    while (j >= 0 && arr[j] > temp) {</span><span>      arr[j + 1] = arr[j];</span><span>      j = j - 1;</span><span>    }</span><span>    arr[j + 1] = temp;</span><span>  }</span><span>  return arr;</span><span>};</span>"
  }
]
